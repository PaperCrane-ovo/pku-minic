// lalrpop 里的约定
grammar;

use crate::ast::*;

// 约束 lexer 的行为
match {
  // 跳过空白符和注释
  r"\s*" => {},
  r"//[^\n\r]*[\n\r]*" => {},
  // 块注释
  r"/\*([^*]|[\r\n]|(\*+([^*/]|[\r\n])))*\*+/" => {},
  // 剩下的情况采用默认方式处理
  _
}

pub CompUnit: CompUnit = <func_def: FuncDef> => CompUnit { <> };

FuncDef: FuncDef = {
  <func_type: FuncType> <ident: Ident> "(" ")" <block: Block> => {
    FuncDef { ident, block, func_type }
  }
}

FuncType: Span<FuncType> = <start:@L> "int" <end:@R> => FuncType::Int.into_span(start, end);

Block: Span<Block> = {
    <start:@L> "{" <items: BlockItem*> "}" <end:@R> => {
        let mut has_return:bool = false;
        let mut temp = Vec::<BlockItem>::new();
        // 去除第一个return之后的所有stmt
        for item in items {
            match item {
                BlockItem::Stmt{ref stmt} => {
                    if let Stmt::Return(_) = stmt.node {
                        if has_return {
                            continue;
                        }
                        has_return = true;
                    }
                },
                _ => {
                    if has_return {
                        continue;
                    }
                }
            }
            temp.push(item.clone());
        }
        Block { items: temp }.into_span(start, end)
    }
}

BlockItem: BlockItem = {
  <stmt: Stmt> => BlockItem::Stmt{<>},
  <decl: Decl> => BlockItem::Decl{<>},
};

Decl: Decl = {
    <var_decl: VarDecl> => Decl::Var(<>),
    <const_decl: ConstDecl> => Decl::Const(<>),
}

BType: Span<BType> = <start:@L> "int" <end:@R> => BType::Int.into_span(start, end);

VarDecl: Span<VarDecl> = {
    <start:@L> <ty:BType> <mut defs:(<VarDef> ",")*> <def: VarDef> ";" <end:@R> => {
        defs.push(def);
        VarDecl { ty, defs }.into_span(start, end)
    }
}

VarDef : VarDef = {
    <ident: Ident> => VarDef{ident:ident, init:None},
    <ident: Ident> "=" <init:InitVal> => VarDef{ident:ident, init:Some(init)},
}

InitVal: InitVal = {
    <exp:Exp> => InitVal{<>}
}

ConstDecl: Span<ConstDecl> = {
    <start:@L> "const" <ty:BType> <mut defs:(<ConstDef> ",")*> <def: ConstDef> ";" <end:@R> => {
        defs.push(def);
        ConstDecl { ty, defs }.into_span(start, end)
    }
}

ConstDef : ConstDef = {
    <ident: Ident> "=" <exp:ConstExp> => ConstDef{<>},
}

ConstExp: ConstExp = {
    <exp:Exp> => ConstExp{<>}
}




Stmt: Span<Stmt> = {
    <start:@L> "return" <exp: Exp> ";" <end:@R> => Stmt::Return(Return{exp:exp}).into_span(start, end),
    <start:@L> <ident:Ident> "=" <exp: Exp> ";" <end:@R> => Stmt::Assign{ident:ident, exp:exp}.into_span(start, end),
};

Exp: Exp = <lor_exp:LOrExp> => <>;

PrimaryExp: Exp = {
    "(" <exp: Exp> ")" => <>,
    <num:Number> => Exp::Number(<>),
    Ident => Exp::LVar(<>),
}


UnaryExp: Exp = {
    <primary_exp: PrimaryExp> => <>,
    <unary_op: UnaryOp> <unary_exp:UnaryExp> => Exp::UnaryExp{op:unary_op, exp:Box::new(unary_exp)},
    
}

UnaryOp: Span<MyUnaryOp> = {
    <start:@L> "-" <end:@R> => MyUnaryOp::Neg.into_span(start, end),
    <start:@L> "!" <end:@R> => MyUnaryOp::Not.into_span(start, end),
    <start:@L> "+" <end:@R> => MyUnaryOp::Pos.into_span(start, end),
}

MulExp: Exp = {
    <unary_exp: UnaryExp> => <>,
    <mul_exp: MulExp> <mul_op:MulOp> <unary_exp: UnaryExp> => Exp::BinaryExp{op:mul_op, exp1:Box::new(mul_exp), exp2:Box::new(unary_exp)},
}

MulOp: Span<MyBinaryOp> = {
    <start:@L> "*" <end:@R> => MyBinaryOp::Mul.into_span(start, end),
    <start:@L> "/" <end:@R> => MyBinaryOp::Div.into_span(start, end),
    <start:@L> "%" <end:@R> => MyBinaryOp::Mod.into_span(start, end),
}

AddExp: Exp = {
    <mul_exp: MulExp> => <>,
    <add_exp: AddExp> <add_op:AddOp> <mul_exp: MulExp> => Exp::BinaryExp{op:add_op, exp1:Box::new(add_exp), exp2:Box::new(mul_exp)},
}

AddOp: Span<MyBinaryOp> = {
    <start:@L> "+" <end:@R> => MyBinaryOp::Add.into_span(start, end),
    <start:@L> "-" <end:@R> => MyBinaryOp::Sub.into_span(start, end),
}

RelExp: Exp = {
    <add_exp: AddExp> => <>,
    <rel_exp: RelExp> <rel_op:RelOp> <add_exp: AddExp> => Exp::BinaryExp{op:rel_op, exp1:Box::new(rel_exp), exp2:Box::new(add_exp)},
}

RelOp: Span<MyBinaryOp> = {
    <start:@L> "<" <end:@R> => MyBinaryOp::Lt.into_span(start, end),
    <start:@L> "<=" <end:@R> => MyBinaryOp::Le.into_span(start, end),
    <start:@L> ">" <end:@R> => MyBinaryOp::Gt.into_span(start, end),
    <start:@L> ">=" <end:@R> => MyBinaryOp::Ge.into_span(start, end),
}

EqExp: Exp = {
    <rel_exp: RelExp> => <>,
    <eq_exp: EqExp> <eq_op:EqOp> <rel_exp: RelExp> => Exp::BinaryExp{op:eq_op, exp1:Box::new(eq_exp), exp2:Box::new(rel_exp)},
}

EqOp: Span<MyBinaryOp> = {
    <start:@L> "==" <end:@R> => MyBinaryOp::Eq.into_span(start, end),
    <start:@L> "!=" <end:@R> => MyBinaryOp::Ne.into_span(start, end),
}

LAndExp: Exp = {
    <eq_exp: EqExp> => <>,
    <land_exp: LAndExp> <start:@L> "&&" <end:@R> <eq_exp: EqExp> => Exp::BinaryExp{op: MyBinaryOp::LAnd.into_span(start,end), exp1:Box::new(land_exp), exp2:Box::new(eq_exp)},
}

LOrExp: Exp = {
    <land_exp: LAndExp> => <>,
    <lor_exp: LOrExp> <start:@L> "||" <end:@R> <land_exp: LAndExp> => Exp::BinaryExp{op: MyBinaryOp::LOr.into_span(start,end), exp1:Box::new(lor_exp), exp2:Box::new(land_exp)},
}

Number: Span<i32> = <start:@L> <num:IntConst> <end:@R> => num.into_span(start, end);




// 如果匹配到标识符, 就返回这个字符串
// 一对尖括号在此处指代的是正则表达式匹配到的字符串 (&str)
// 关于尖括号到底代表什么, 请 RTFM
Ident: Span<String> = <start:@L> <ident: r"[_a-zA-Z][_a-zA-Z0-9]*"> <end:@R> => ident.to_string().into_span(start, end);

// 对整数字面量的处理方式: 把匹配到的字符串按对应进制转换成数字
IntConst: i32 = {
  r"[1-9][0-9]*" => i32::from_str_radix(<>, 10).unwrap(),
  r"0[0-7]*" => i32::from_str_radix(<>, 8).unwrap(),
  r"0[xX][0-9a-fA-F]+" => i32::from_str_radix(&<>[2..], 16).unwrap(),
}
